# 堆

[可视化](https://visualgo.net/zh/heap)

> 堆是一种特殊的二叉树，堆只按照堆属性来进行排序，相较于普通的树，推的优点在于其省略了大量的‘额外的信息’（有时候很重要，不得不用树来实现）所以其实现比树更为简单。

## 堆的排序方式

堆是按照其属性进行排序。

一个堆只需要满足一下一个特点即可

在最大堆中，只需要保证其父节点大于所有子节点。

在最小堆中则相反。

以下所有的演示均为最大堆演示，最小堆相反即可。

## 堆数据的保存

创建堆

```cpp
struct Greater_HeAp{
    int a[1000000] = {};
    int SiZe = 0;
};
```



堆只需要一个数组来实现，其他所有的数据都是不必要的。

例如 （这是一个已经排好的数据）

```
[34,33,25,23,19,7,5,2]
```

那么我们只需要如下的存储方式

![堆数据的保存](.pictures/堆_1.png)

由图我们不难发现有如下的表示方式

另某一个节点为第 i 个节点

$$ fa(i) = \lfloor\frac{i}2\rfloor $$

$$Lson=i\times2$$

$$Rson=i\times2+1$$

代码

```cpp
// 存在则返回大于0 的数 否则返回 0  
int Lson(const int &i) const {return i * 2 > SiZe ? 0 : i * 2;}
int Rson(const int &i) const {return i * 2 + 1 > SiZe ? 0 : i * 2 + 1;}
int Father(const int &i)const{return i / 2;}
```



> 注意最大节点并没有父节点，以及有最下层的节点可能没有叶子了，因此要判断范围是否正确

有这个公式我们可以知道，我们可以话费$O(1)$ 的时间复杂度找到它的子节点和父节点。

> 在堆与二叉树中不同的一点是，只有上一层级的叶排满才可以排下一层，如果破坏了这一特性，那么堆变没有那么方便的使用特性了。

## 二叉堆的基本操作

### 堆的查询操作

只要考虑a[1] 是否存在即可

若没有的话则需要返回一个不存在的值来说明是否存在。

但建议在使用的时候先进行数据大小的查询

```cpp
int size(){ return SiZe ; }
int top(){
    if(size > 0) return a[1];
    return INT_MIN;
}
```



### 堆的插入操作

既然我们已经保存了上面的堆，那么堆怎么进行插入呢。

加入我们插入一个 `40`

1. 创建最下左端的子节点。

   创建 9 号子节点。

   ![推的插入操作(1)](.pictures\堆_2.png)

   ```cpp
   a[9] = 40;
   ```

   

2. 子节点与父节点比较，若比父节点大则交换，一直到无法交换为止

   由于其他堆已经做好比较了，所以交换并不会改变原有的结构。

   具体可以到页首提供的链接看一看。

   ```cpp
   while(i > 1 && a[i / 2] < a[i]) swap(a[i] , a[i / 2]) , i/=2;
   ```

   那么插入的操作可以为

   ```cpp
   void swap(int &a , int &b){ int t = a ; a = b ; b = t;}
   void insert(const int&k){
       size++;
       a[size] = k;
       int i = size;
       while(Father(i) && a[Father(i)] < a[i]) swap(a[i] , aFather(i)]) , i /= 2;
   }
   ```

   ### 堆的弹出操作

   在堆中，将最大数弹出后，那么将会产生一个空穴。因此我们需要将此空穴变换才可以进行别的操作。那么我们为了保持堆的属性，我们不妨将最右端的子叶填充到顶堆。那么我们就可以对这个进行重新交换的操作。

   代码

   ```cpp
   void pop(){
       a[1] = a[size--];
       int i = 1;
       while(Lson(i) || Rson(i)){
           if(a[Lson(i)] > a[i]) swap(a[Lson(i)] , a[i]) , i = Lson(i);
           else if(a[Rson(i)] > a[i]) swap(a[Rson(i)] , a[i]) , i = Rson(i);
           else break;
       }
   }
   ```
在C++ 中使用模板代替 int , 使用 vector 代替数组。

目前的代码(待更新)
```cpp

struct Greater_HeAp{
    int a[1000000] = {};
    int SiZe = 0;
    
     
    int size(){ return SiZe ; }
    int top(){
        if(size > 0) return a[1];
        return INT_MIN;
    }
    int Lson(const int &i) const {return i * 2 > SiZe ? 0 : i * 2;}
    int Rson(const int &i) const {return i * 2 + 1 > SiZe ? 0 : i * 2 + 1;}
    int Father(const int &i)const{return i / 2;}
    void swap(int &a , int &b){ int t = a ; a = b ; b = t;}
    void insert(const int&k){
        int i = ++SiZe;
        a[i] = k;
        while(Father(i) && a[Father(i)] < a[i]) swap(a[i] , a[Father(i)]) , i /= 2;
    } 
    void pop(){
        a[1] = a[size--];
        int i = 1;
        while(Lson(i) || Rson(i)){
            if(a[Lson(i)] > a[i]) swap(a[Lson(i)] , a[i]) , i = Lson(i);
            else if(a[Rson(i)] > a[i]) swap(a[Rson(i)] , a[i]) , i = Rson(i);
            else break;
        }
    } 
};
```
   

